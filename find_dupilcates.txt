import numpy as np
import numpy.ma as ma
import math

def compute_all_stats(
    eigval_list,
    threshold=1e-12,
    spread_methods=("variance", "mad"),  # e.g. ["variance", "mad"]
    ddof=1,
    scale="normal",
    qfim_mats_list=None,   
    dataset_sizes=None,    
    n=1,                   # overshadowed in the old code, kept for signature
    n_ctrl=None,
    n_reserv=None,
    trotter_step=None,
):
    """
    Vectorized version of stats computations over 'eigval_list' (shape [n_draws, M]).
    We remove the explicit Python for-loop for IPR, raw Abbas dimension, etc.,
    and rely on NumPy's built-in array operations.

    Additionally, we compute variance-of-nonzero-eigenvalues in two ways
    (Approach A = average of per-draw variance, Approach B = single global variance)
    for both raw and normalized QFIM eigenvalues.
    """

    # ---------------------------
    # 1) Convert eigvals to 2D array, zero out small entries
    # ---------------------------
    arr = np.array(eigval_list, dtype=float)
    if arr.ndim == 1:
        arr = arr[np.newaxis, :]
    arr = np.where(arr < threshold, 0.0, arr)

    n_draws, M = arr.shape

    # ---------------------------
    # 2) Basic stats, vectorized (raw QFIM eigenvalues)
    # ---------------------------
    ranks_per_draw = np.count_nonzero(arr, axis=1)  # rank = # of nonzero
    var_all_per_draw = np.var(arr, axis=1, ddof=ddof)
    trace_per_draw = np.sum(arr, axis=1)

    # variance of nonzero subset => masked arrays
    masked = ma.masked_where(arr <= 0.0, arr)
    var_nonzero_ma = ma.var(masked, axis=1, ddof=ddof)
    var_nonzero_per_draw = var_nonzero_ma.filled(0.0)

    # Already Approach A: average the per-draw variance
    avg_var_nonzero = float(var_nonzero_per_draw.mean()) if var_nonzero_per_draw.size>0 else 0.0

    # [NEW: Approach B for raw eigenvalues: gather all nonzero & compute one variance]
    global_nonzero_raw = arr[arr > 0.0]  # flatten across all draws
    if global_nonzero_raw.size > 1:
        global_var_nonzero = float(np.var(global_nonzero_raw, ddof=ddof))
    else:
        global_var_nonzero = 0.0

    # Some other existing stats
    var_norm_rank_per_draw = np.where(ranks_per_draw > 0,
                                      var_all_per_draw / ranks_per_draw,
                                      0.0)
    trace_norm_rank_per_draw = np.where(ranks_per_draw > 0,
                                        trace_per_draw / ranks_per_draw,
                                        0.0)

    # ---------------------------
    # 3) Normalized QFIM eigenvalues
    # ---------------------------
    trace_mask = (trace_per_draw>0)
    arr_norm = np.zeros_like(arr)
    arr_norm[trace_mask] = arr[trace_mask] / trace_per_draw[trace_mask, np.newaxis]

    # (A) Approach A: variance per draw of nonzero (normalized) eigenvalues, then average
    masked_norm = ma.masked_where(arr_norm <= 0.0, arr_norm)
    var_nonzero_norm_ma = ma.var(masked_norm, axis=1, ddof=ddof)
    var_nonzero_norm_per_draw = var_nonzero_norm_ma.filled(0.0)
    if var_nonzero_norm_per_draw.size > 0:
        avg_var_nonzero_norm = float(var_nonzero_norm_per_draw.mean())
    else:
        avg_var_nonzero_norm = 0.0

    # (B) Approach B: flatten all nonzero normalized eigenvalues -> single variance
    global_nonzero_norm = arr_norm[arr_norm > 0.0]
    if global_nonzero_norm.size > 1:
        global_var_nonzero_norm = float(np.var(global_nonzero_norm, ddof=ddof))
    else:
        global_var_nonzero_norm = 0.0

    # ---------------------------
    # 4) IPR-based dimension (example)
    # ---------------------------
    sum_of_squares = np.sum(arr**2, axis=1)
    ipr_raw_per_draw = np.divide(trace_per_draw**2, sum_of_squares,
                                 out=np.zeros_like(trace_per_draw),
                                 where=(sum_of_squares>0))

    # normalized IPR
    sum_norm_sq = np.sum(arr_norm**2, axis=1)
    ipr_norm_per_draw = np.divide(1.0, sum_norm_sq,
                                  out=np.zeros_like(sum_norm_sq),
                                  where=(sum_norm_sq>0))

    # ---------------------------
    # 5) Abbas-based dimension (raw, normalized) ...
    #    [unchanged from your snippet, omitted for brevity]
    # ---------------------------

    # Just do something for abbas as well
    gamma = 1.0
    if n_draws>1 and math.log(n_draws)!=0:
        alpha = (gamma * n_draws) / (2.0 * np.log(n_draws))
    else:
        alpha = 0.0

    val_raw = 1.0 + alpha * arr
    val_raw[val_raw<=0] = 1e-15
    abbas_raw_per_draw = np.sum(np.log(val_raw), axis=1)

    val_norm = 1.0 + alpha * arr_norm
    val_norm[val_norm<=0] = 1e-15
    abbas_norm_per_draw = np.sum(np.log(val_norm), axis=1)

    # Example aggregates
    avg_abbas_raw  = float(abbas_raw_per_draw.mean())  if abbas_raw_per_draw.size>0  else 0.0
    avg_abbas_norm = float(abbas_norm_per_draw.mean()) if abbas_norm_per_draw.size>0 else 0.0

    # ---------------------------
    # 6) Spread-of-log metrics (unchanged from your snippet)
    # ---------------------------
    arr_2d = arr.copy()  # shape [n_draws, M]
    spread_results = {}
    for method in spread_methods:
        per_draw = spread_per_sample_vectorized(
            arr_2d,
            method=method,
            threshold=threshold,
            ddof=ddof,
            scale=scale,
            n_ctrl=n_ctrl,
            n_reserv=n_reserv,
            trotter_step=trotter_step,
        )
        spread_mean = float(per_draw.mean()) if per_draw.size>0 else 0.0
        spread_std  = float(per_draw.std())  if per_draw.size>1 else 0.0
        pooled_val  = float(spread_pooling_vectorized(
            arr_2d, method=method, threshold=threshold, ddof=ddof, scale=scale
        ))
        prefix = method.lower()
        spread_results[f"spread_mean_per_sample_{prefix}_{scale}"] = spread_mean
        spread_results[f"spread_std_per_sample_{prefix}_{scale}"]  = spread_std
        spread_results[f"spread_val_pooled_{prefix}_{scale}"]      = pooled_val

    # If you also need the "no-log" version:
    for method in spread_methods:
        per_draw_nolog = spread_per_sample_vectorized_nolog(
            arr_2d,
            method=method,
            threshold=threshold,
            ddof=ddof,
            scale=scale,
            n_ctrl=n_ctrl,
            n_reserv=n_reserv,
            trotter_step=trotter_step,
        )
        spread_results[f"spread_metric_{method}_nolog"] = (
            per_draw_nolog[0] if per_draw_nolog.size > 0 else 0.0
        )

    # ---------------------------
    # 7) Effective dimension from QFIMs (unchanged)
    # ---------------------------
    effective_dim_avg_draws = 0.0
    effective_dim_of_mean   = 0.0
    if qfim_mats_list is not None and len(qfim_mats_list) > 0:
        # [ ... same logic as your snippet that computes
        # effective_dimension_avg_over_draws + effective_dimension_of_mean_qfim ...]
        pass

    # ---------------------------
    # 8) Build final dictionary
    # ---------------------------
    metrics = {
        # Per-draw lists
        "QFIM_ranks": ranks_per_draw,
        "var_all_eigenvals_per_draw": var_all_per_draw,
        "var_nonzero_eigenvals_per_draw": var_nonzero_per_draw,
        "trace_eigenvals_per_draw": trace_per_draw,

        # Aggregated variance of nonzero RAW (Approach A & B)
        "absolute_scale_avg_var_nonzero": avg_var_nonzero,          # Approach A
        "absolute_scale_global_var_nonzero": global_var_nonzero,    # Approach B

        # Aggregated variance of nonzero NORMALIZED (Approach A & B)
        "normalized_avg_var_nonzero":  avg_var_nonzero_norm,        # Approach A
        "normalized_global_var_nonzero": global_var_nonzero_norm,   # Approach B

        # Abbas draws & means
        "abbas_deffs_raw_per_draw": abbas_raw_per_draw,
        "avg_abbas_deffs_raw":      avg_abbas_raw,
        "abbas_deffs_norm_per_draw": abbas_norm_per_draw,
        "avg_abbas_deffs_norm":      avg_abbas_norm,

        # IPR draws & means
        "ipr_deffs_raw_per_draw": ipr_raw_per_draw,
        "ipr_deffs_norm_per_draw": ipr_norm_per_draw,

        # Effective dimensions (two ways) if needed
        "effective_dimension_avg_over_draws": effective_dim_avg_draws,
        "effective_dimension_of_mean_qfim":   effective_dim_of_mean,
    }
    metrics.update(spread_results)

    return metrics
